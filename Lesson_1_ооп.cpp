// Lesson_1_ооп.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <iomanip>

union Test
{
    int one;                        // 1ый байт    2ой байт    3ий байт     4ый байт  
    //  в компютере слева направо      4ый баыт    3ий байт    2ой байт     1ый байт
    char two;  // char только 1 байт   1ый байт
};                                 //  ^ тут (4ый и 1ый) происходит пересечение и объединение

//  struct Test
//  {
//     int one;
//     char two;
//  };
// 
// int main1()
// {
//     Test some;
//     some.one = 65;
//     std::cout << some.two << std::endl;  // так можно только в union
//                                          // в struct так нельзя, нельзя обратится к some.two,
//                                          //  пока он не инициализирован
//     return 0;
// }

union Kuku
{
    int one;      // 4ый  3ий  2ой  1ый
    char two[4];  // 0ой  1ый  2ой  3ий
};

Kuku Enter()
{
    Kuku temp;
    std::cout << "Enter inegral number\n";
    std::cin >> temp.one;
    return temp;
}

void LookBytes(Kuku un)
{
    std::cout << "Bytes of the number:\n";
    std::cout << "In decimal: \n";
    for (int i = 0; i < 4; i++)
    {
        std::cout << (int)un.two[i] << '\t';
    }
    std::cout << "\nIn hex:\n";
    for (int i = 0; i < 4; i++) {
        std::cout << std::hex << (int)un.two[i] << '\t';
    }

   
}

int main2() {
    some = Enter();
    LookBytes(some);

    return 0;
}


/*
 Структура - составной объект, внуть которого входят другие меньшие
 составляющие. 
 Дают возможность хранить переменные с разными типами данных.
 Благодаря структурам с несколькими составляющими структуры мы можем 
 работать как с единым целым.
 При создании структуры мы создаем собсвенный пользовательский тип данных.
 Поля структуры в памяти расположены последовательно.
 Но могут возникать "дырки", так как происходит выравнивание полей 
 структуры по старшему элементу. 
 
*/



////////////////////////////////////////////////////////////////

// константный указатель и указатель на константу


int main3() {
    int a = 15;
    int b = 30;
    int* pb = &b; 
    int* const pa = &a;     // константный указатель, адрес стал константным и его нельзя менять
    
    // const int* pa = &a;  // указатель на константу, теперь мы не можем менять то, 
                            //  что находится по этому адресу, напр *pa = &b - нельзя
    *pa = 100;              // с помощью оператора разименования мы обращаемся к значению,
                            // получаем доступ к этой области памяти, получаем то, что там находится
                            // через указатель не можем поменять *pa, так как мы сделали указатель на константу const int* pa = &a;
    a = 200;
    std::cout << a << std::endl;
    int b = 0;
    std::cout << a / b;

    return 0;
}


/*
    ООП
    Возможность в одну "капсулу" связать и сами характеристики объекта,
    и то, что он делает.
    Принципы ООП:
     0. Абстрагирование - некоторая независимость от деталей - независимоть
        способов взаимодействия с объектом от деталей реализации этого объекта.
        Взаимодействие с объектом обеспечивается его интерфейсом.
     1. Инкапсуляция - свойство системы, позволяющее тесно связать данные
        и методы работи с ними внутри класса и сделать данные и детали
        реализации недоступными для других частей системы.
        Инкапсуляция - это прежде всего сокрытие данных.      
        С логической точки зрения, инкапсуляция объединяет поля (свойства 
        объекта) и методы (то, что может делать объект).
        С технической точки зрения, инкапсуляция разделяет класс на
        реализацию и интерфейс.
        Реализация - это закрытая часть класса.
        Интерфейс - это открытая часть класса.
        Как реализовать инкапсуляцию - использовать private и public.
        Public - доступны из внешней программы.
        Private - доступны только внутри класса.
     2. Наследование.
     3. Полиморфизм.

    Аксессоры (доступ) -  бывают двух видов - сэттеры (модификаторы) 
    и гэттеры (инспекторы).
    Предназначение аксэссора - получить доступ к скрытым полям класса.

*/

/*

class Date {        // создаем схему для каждого объекта
                    // скрытая часть (все, что приват - реализация)
    int Day;        // все поля приватный, пока мы не объявили другое
    int Month;
    int Year;
public:
    void SetDay()   // все, что в паблике - интерфейс - взаимодействие с классом
    {}              // а private - реализация

};
*/

class Test {  // создали класс - создали общую схему для создания каждого объекта класса
              // эта запись еще не привела к выделению памяти
    int a1;
    double b;
public:  // интерфейс класса
    void SetOne(int x)  // ф-ия Setter для установки поля x в конкретное значение ( в поле a)
    {                   // Setter - модификатор, т.к. модифицирует значение   
        a1 = x;
    }
    void SetTwo(double y)
    {
        b = y;
    }

    void OutputOne()  
    {
        std::cout << a1 << std::endl;
    }
    void OutputTwo()  
    {
        std::cout << b << std::endl;
    }

    int GetOne()    // гэттер или инспектор - позволяет получить значение поля класса
    {               // и предоставить это значение внешней программе. 
                    // В getter - обязателен return
        return a1;
    }
    double GetTwo()  
    {
        return b;
    }
};

    int main() {  // мейн после класса называют клиентский код - изменения вносим
                  //  в классе, а в мейне ничего при этом не должно меняться
        Test someDate;  // создали экземпляр someDate класса Test
                        // выделилась память на объект типа Test этого класса
                        // в том числе на все его поля (а1, b)
        // someDate.a = 5;  // не работает, т.к. поле а закрыто
        someDate.SetOne(50);
        someDate.SetTwo(20.5);

        someDate.OutputOne();  
        someDate.OutputTwo();

        std::cout << 2 * someDate.GetOne() << std::endl;
        std::cout << 2 * someDate.GetTwo() << std::endl;

        return 0;
    }
